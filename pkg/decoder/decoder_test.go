package decoder

import (
	"reflect"
	"testing"
)

/*
Part 1 - driver card tests

Tests are always two-fold:
1. parsing of the single data structure directly
2. parsing of a complete card structure holding this single data structure (1st and 2nd gen)
*/

// clock stop 0
// serial number 0x09 0x09 0x09 0x09
// month year 0x01 0x20 (01 / 2020)
// type 0x01 (driver data)
// manufacturer code 0x09
// data approval number 0x00 0x01 0x02 0x03 0x04 0x05 0x06 0x07
// personaliser id 0xaa
// embedder assembler id:
//  country code DE 0x44, 0x45
//  module embedder 0x99, 0x99
// manufacturer information 0x00
// ic identifier 0x12, 0x34
var iccIdData = []byte{0x00, 0x09, 0x09, 0x09, 0x09, 0x01, 0x20, 0x01, 0x09, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xaa, 0x44, 0x45, 0x99, 0x99, 0x00, 0x12, 0x34}
var expectedIccFirstGen = CardIccIdentificationFirstGen{
	ClockStop: 0,
	CardExtendedSerialNumber: ExtendedSerialNumberFirstGen{
		SerialNumber:     151587081,
		MonthYear:        MonthYear{1, 32},
		Type:             0x01,
		ManufacturerCode: 0x09,
	},
	CardApprovalNumber: CardApprovalNumber{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07},
	CardPersonaliserID: 0xaa,
	EmbedderIcAssemblerId: EmbedderIcAssemblerId{
		CountryCode:             CountryCode{'D', 'E'},
		ModuleEmbedder:          BCDString{0x99, 0x99},
		ManufacturerInformation: 0x00,
	},
	IcIdentifier: [2]byte{0x12, 0x34},
}
var expectedIccSecondGen = CardIccIdentificationSecondGen{
	ClockStop: 0,
	CardExtendedSerialNumber: ExtendedSerialNumberSecondGen{
		SerialNumber:     151587081,
		MonthYear:        MonthYear{1, 32},
		Type:             0x01,
		ManufacturerCode: 0x09,
	},
	CardApprovalNumber: CardApprovalNumber{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07},
	CardPersonaliserID: 0xaa,
	EmbedderIcAssemblerId: EmbedderIcAssemblerId{
		CountryCode:             CountryCode{'D', 'E'},
		ModuleEmbedder:          BCDString{0x99, 0x99},
		ManufacturerInformation: 0x00,
	},
	IcIdentifier: [2]byte{0x12, 0x34},
}

var testCasesIccIdsFirstGen = []struct {
	data     []byte
	expected CardIccIdentificationFirstGen
}{
	{
		data:     iccIdData,
		expected: expectedIccFirstGen,
	},
}

var testCasesIccIdsSecondGen = []struct {
	data     []byte
	expected CardIccIdentificationSecondGen
}{
	{
		data:     iccIdData,
		expected: expectedIccSecondGen,
	},
}

func TestDecodeCardIccIdentificationFirstGen(t *testing.T) {
	for _, testCase := range testCasesIccIdsFirstGen {
		ii := &CardIccIdentificationFirstGen{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("data icc identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

func TestDecodeCardIccIdentificationSecondGen(t *testing.T) {
	for _, testCase := range testCasesIccIdsSecondGen {
		ii := &CardIccIdentificationSecondGen{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("data icc identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// prefix tags "00 02 00" and "00 02 02"
var cardWithIccIdData = append([]byte{0x00, 0x02, 0x00, 0, byte(len(iccIdData))}, append(iccIdData, append([]byte{0x00, 0x02, 0x02, 0, byte(len(iccIdData))}, iccIdData...)...)...)
var expectedCardWithIccId = Card{
	CardIccIdentificationFirstGen:  expectedIccFirstGen,
	CardIccIdentificationSecondGen: expectedIccSecondGen,
}

var testCasesCardWithCardIccIds = []struct {
	data     []byte
	expected Card
}{
	{
		data:     cardWithIccIdData,
		expected: expectedCardWithIccId,
	},
}

func TestCardWithIcc(t *testing.T) {
	for _, testCase := range testCasesCardWithCardIccIds {
		ii := &Card{}
		data := testCase.data
		UnmarshalTLV(data, ii)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("data icc identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

var cIdData = []byte{0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, 0x00}
var expectedCId = CardChipIdentification{
	IcSerialNumber:           [4]byte{0x07, 0x06, 0x05, 0x04},
	IcManufacturingReference: [4]byte{0x03, 0x02, 0x01, 0x00},
}

var testCasesCIds = []struct {
	data     []byte
	expected CardChipIdentification
}{
	{
		data:     cIdData,
		expected: expectedCId,
	},
}

func TestDecodeCardChipId(t *testing.T) {
	for _, testCase := range testCasesCIds {
		ii := &CardChipIdentification{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("data chip identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// prefix tag 00 05 00 / 00 05 02
var cardWithChipIdData = append([]byte{0x00, 0x05, 0x00, 0, byte(len(cIdData))}, append(cIdData, append([]byte{0x00, 0x05, 0x02, 0, byte(len(cIdData))}, cIdData...)...)...)
var expectedCardWithCIds = Card{
	CardChipIdentificationFirstGen:  expectedCId,
	CardChipIdentificationSecondGen: expectedCId, // same for first and second gen
}

var testCasesCardWithCardChipIds = []struct {
	data     []byte
	expected Card
}{
	{
		data:     cardWithChipIdData,
		expected: expectedCardWithCIds,
	},
}

func TestCardWithChipId(t *testing.T) {
	for _, testCase := range testCasesCardWithCardChipIds {
		ii := &Card{}
		data := testCase.data
		UnmarshalTLV(data, ii)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("data chip identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// type of tacho card id 0x01 (driver data)
// card structure version 0x00 0x00
// no of events per type 0x0c (12)
// no of faults per type 0x18 (24)
// activity structure length 0x35 0xd0 (13776)
// no of card vehicle records 0x00 0xc8 (200)
// no of card place records 0x70 (112)
var driverCardApplicationIdentificationDataFirstGen = []byte{0x01, 0x00, 0x00, 0x0c, 0x18, 0x35, 0xd0, 0x00, 0xc8, 0x70}

var expectedDriverCardAppIdFirstGen = DriverCardApplicationIdentificationFirstGen{
	TypeOfTachographCardId:          1,
	CardStructureVersion:            CardStructureVersion{0, 0},
	NoOfEventsPerTypeFirstGen:       12,
	NoOfFaultsPerTypeFirstGen:       24,
	ActivityStructureLengthFirstGen: 13776,
	NoOfCardVehicleRecordsFirstGen:  200,
	NoOfCardPlaceRecordsFirstGen:    112,
}

var testCasesDriverCardApplicationIdFirstGen = []struct {
	data     []byte
	expected DriverCardApplicationIdentificationFirstGen
}{
	{
		data:     driverCardApplicationIdentificationDataFirstGen,
		expected: expectedDriverCardAppIdFirstGen,
	},
}

func TestDecodeDriverCardApplicationIdentificationFirstGen(t *testing.T) {
	for _, testCase := range testCasesDriverCardApplicationIdFirstGen {
		ii := &DriverCardApplicationIdentificationFirstGen{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("data chip identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// type of tacho card id 0x01 (driver data)
// card structure version 0x00 0x00
// no of events per type 0x0c (12)
// no of faults per type 0x18 (24)
// activity structure length 0x35 0xd0 (13776)
// no of card vehicle records 0x00 0xc8 (200)
// no of card place records 0x00 0x70 (112)
// no of gnss ad records 0x01 0x50 (336)
// no of specific condition records 0x00 0x70 (112)
// no of card vehicle unit records 0x00 0xc8 (200)
var driverCardApplicationIdentificationDataSecondGen = []byte{0x01, 0x00, 0x00, 0x0c, 0x18, 0x35, 0xd0, 0x00, 0xc8, 0x00, 0x70, 0x01, 0x50, 0x00, 0x70, 0x00, 0xc8}

var expectedDriverCardAppIdSecondGen = DriverCardApplicationIdentificationSecondGen{
	TypeOfTachographCardId:           1,
	CardStructureVersion:             CardStructureVersion{0, 0},
	NoOfEventsPerTypeSecondGen:       12,
	NoOfFaultsPerTypeSecondGen:       24,
	ActivityStructureLengthSecondGen: 13776,
	NoOfCardVehicleRecordsSecondGen:  200,
	NoOfCardPlaceRecordsSecondGen:    112,
	NoOfGNSSADRecords:                336,
	NoOfSpecificConditionRecords:     112,
	NoOfCardVehicleUnitRecords:       200,
}

var testCasesDriverCardApplicationIdSecondGen = []struct {
	data     []byte
	expected DriverCardApplicationIdentificationSecondGen
}{
	{
		data:     driverCardApplicationIdentificationDataSecondGen,
		expected: expectedDriverCardAppIdSecondGen,
	},
}

func TestDecodeDriverCardApplicationIdentificationSecondGen(t *testing.T) {
	for _, testCase := range testCasesDriverCardApplicationIdSecondGen {
		ii := &DriverCardApplicationIdentificationSecondGen{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("data chip identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// prefix tag 05 01 00 / 05 01 02
var cardWithDriverCardApplicationIdsData = append([]byte{0x05, 0x01, 0x00, 0, byte(len(driverCardApplicationIdentificationDataFirstGen))}, append(driverCardApplicationIdentificationDataFirstGen, append([]byte{0x05, 0x01, 0x02, 0, byte(len(driverCardApplicationIdentificationDataSecondGen))}, driverCardApplicationIdentificationDataSecondGen...)...)...)
var expectedCardWithDriverCardApplicationIds = Card{
	DriverCardApplicationIdentificationFirstGen:  expectedDriverCardAppIdFirstGen,
	DriverCardApplicationIdentificationSecondGen: expectedDriverCardAppIdSecondGen,
}

var testCasesCardWithDriverCardApplicationIds = []struct {
	data     []byte
	expected Card
}{
	{
		data:     cardWithDriverCardApplicationIdsData,
		expected: expectedCardWithDriverCardApplicationIds,
	},
}

func TestCardWithDriverCardApplicationIds(t *testing.T) {
	for _, testCase := range testCasesCardWithDriverCardApplicationIds {
		ii := &Card{}
		data := testCase.data
		UnmarshalTLV(data, ii)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("data chip identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// card issuing member state 0x0a
// card number 0x31 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 ("1000000000000000")
// card issuing authority name 0x01 0x41 0x41 0x41 0x41 0x41 0x41 0x41 0x20 ... 0x20 (codepage 1, "AAAAAAA                            ")
// card issue date 0x5e 0x7b 0xf0 0x80 (2020-03-26T00:00:00Z)
// card validity begin 0x5e 0x7b 0xf0 0x80 (2020-03-26T00:00:00Z)
// card expiry date 0x67 0xe3 0x43 0x7f (2025-03-25T23:59:59Z)
var cardIdentificationData = []byte{0x0a, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x01, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5e, 0x7b, 0xf0, 0x80, 0x5e, 0x7b, 0xf0, 0x80, 0x67, 0xe3, 0x43, 0x7f}

var expectedCardIdentification = CardIdentification{
	CardIssuingMemberState: 0x0a,
	CardNumber:             CardNumber{0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30},
	CardIssuingAuthorityName: Name{
		CodePage: 1,
		Name:     [35]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
	},
	CardIssueDate:     TimeReal{Timedata: [4]byte{0x5e, 0x7b, 0xf0, 0x80}},
	CardValidityBegin: TimeReal{Timedata: [4]byte{0x5e, 0x7b, 0xf0, 0x80}},
	CardExpiryDate:    TimeReal{Timedata: [4]byte{0x67, 0xe3, 0x43, 0x7f}},
}

var testCasesCardIdentification = []struct {
	data     []byte
	expected CardIdentification
}{
	{
		data:     cardIdentificationData,
		expected: expectedCardIdentification,
	},
}

func TestDecodeCardIdentification(t *testing.T) {
	for _, testCase := range testCasesCardIdentification {
		ii := &CardIdentification{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("data chip identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// card holder name - holder surname: 0x01, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, ..., 0x20 (code page 1, "AAAAA                              ")
// card holder name - holder first names: 0x01, 0x42, 0x42, 0x42, 0x42, 0x42, 0x20, ..., 0x20 (code page 1, "BBBBB                              ")
// card holder birthday 0x19 0x70 0x02 0x01 (1970-02-01)
// card holder preferred language 0x64 0x65 ("de")
var driverCardHolderData = []byte{0x01, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x42, 0x42, 0x42, 0x42, 0x42, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x19, 0x70, 0x02, 0x01, 0x64, 0x65}

var expectedDriverCardHolderIdentification = DriverCardHolderIdentification{
	CardHolderName: HolderName{
		HolderSurname: Name{
			CodePage: 1,
			Name:     [35]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
		},
		HolderFirstNames: Name{
			CodePage: 1,
			Name:     [35]byte{0x42, 0x42, 0x42, 0x42, 0x42, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
		},
	},
	CardHolderBirthDate: Datef{
		Year:  BCDString{0x19, 0x70},
		Month: BCDString{0x02},
		Day:   BCDString{0x01},
	},
	CardHolderPreferredLanguage: Language{0x64, 0x65},
}

var testCasesDriverCardHolderIdentification = []struct {
	data     []byte
	expected DriverCardHolderIdentification
}{
	{
		data:     driverCardHolderData,
		expected: expectedDriverCardHolderIdentification,
	},
}

func TestDecodeDriverCardHolderIdentification(t *testing.T) {
	for _, testCase := range testCasesDriverCardHolderIdentification {
		ii := &DriverCardHolderIdentification{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("data chip identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// prefix tag 05 20 00 / 05 20 02
var cardIdentificationAndDriverCardHolderIdentificationData = append(cardIdentificationData, driverCardHolderData...)
var cardWithCardIdentificationAndDriverCardHolderIdentificationData = append([]byte{0x05, 0x20, 0x00, 0, byte(len(cardIdentificationAndDriverCardHolderIdentificationData))}, append(cardIdentificationAndDriverCardHolderIdentificationData, append([]byte{0x05, 0x20, 0x02, 0, byte(len(cardIdentificationAndDriverCardHolderIdentificationData))}, cardIdentificationAndDriverCardHolderIdentificationData...)...)...)
var expectedCardWithCardIdentificationAndDriverCardHolderIdentification = Card{
	CardIdentificationAndDriverCardHolderIdentificationFirstGen: CardIdentificationAndDriverCardHolderIdentification{
		CardIdentification:             expectedCardIdentification,
		DriverCardHolderIdentification: expectedDriverCardHolderIdentification,
	},
	CardIdentificationAndDriverCardHolderIdentificationSecondGen: CardIdentificationAndDriverCardHolderIdentification{
		CardIdentification:             expectedCardIdentification,
		DriverCardHolderIdentification: expectedDriverCardHolderIdentification,
	},
}

var testCasesCardWithCardIdentificationAndDriverCardHolderIdentification = []struct {
	data     []byte
	expected Card
}{
	{
		data:     cardWithCardIdentificationAndDriverCardHolderIdentificationData,
		expected: expectedCardWithCardIdentificationAndDriverCardHolderIdentification,
	},
}

func TestCardWithCardIdentificationAndDriverCardHolderIdentification(t *testing.T) {
	for _, testCase := range testCasesCardWithCardIdentificationAndDriverCardHolderIdentification {
		ii := &Card{}
		data := testCase.data
		UnmarshalTLV(data, ii)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("data chip identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

/*
Part 2 - VU data tests

The vu data structures (overview, activities, events and faults, detailed speed, technical data - each 1st and 2nd gen) are tested
1. every component individually
2. the complete structure
*/

// Overview 1st gen

// member state cert

var memberStateCertificateFirstGenData = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1}
var expectedMemberStateCertificateFirstGen = MemberStateCertificateFirstGen{
	Certificate: [194]byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1},
}

var testCasesMemberStateCertificateFirstGen = []struct {
	data     []byte
	expected MemberStateCertificateFirstGen
}{
	{
		data:     memberStateCertificateFirstGenData,
		expected: expectedMemberStateCertificateFirstGen,
	},
}

func TestDecodeMemberStateCertificateFirstGen(t *testing.T) {
	for _, testCase := range testCasesMemberStateCertificateFirstGen {
		ii := &MemberStateCertificateFirstGen{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("member state certificate failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// vu certificate

var vuCertificateFirstGenData = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1}
var expectedVuCertificateFirstGen = VuCertificateFirstGen{
	Certificate: [194]byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1},
}

var testCasesVuCertificateFirstGen = []struct {
	data     []byte
	expected VuCertificateFirstGen
}{
	{
		data:     memberStateCertificateFirstGenData,
		expected: expectedVuCertificateFirstGen,
	},
}

func TestDecodeVuCertificateFirstGen(t *testing.T) {
	for _, testCase := range testCasesVuCertificateFirstGen {
		ii := &VuCertificateFirstGen{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vu certificate failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// vehicle identification number

// "ABCDEFGHIJKLMNOPQ"
var vehicleIdentificationNumberData = []byte{0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51}
var expectedVehicleIdentificationNumber = VehicleIdentificationNumber{0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51}

var testCasesVehicleIdentificationNumber = []struct {
	data     []byte
	expected VehicleIdentificationNumber
}{
	{
		data:     vehicleIdentificationNumberData,
		expected: expectedVehicleIdentificationNumber,
	},
}

func TestDecodeVehicleIdentificationNumber(t *testing.T) {
	for _, testCase := range testCasesVehicleIdentificationNumber {
		ii := &VehicleIdentificationNumber{}
		data := testCase.data
		globalSizes := make(map[string]int)

		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vehicle identification number: %v should be %v", ii, testCase.expected)
		}
	}
}

// vehicle registration identification

//
var vehicleRegistrationIdentificationData = []byte{0x0a, 0x01, 0x41, 0x42, 0x43, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20}
var expectedVehicleRegistrationIdentification = VehicleRegistrationIdentification{
	VehicleRegistrationNation: 0x0a,
	VehicleRegistrationNumber: VehicleRegistrationNumber{
		CodePage:         1,
		VehicleRegNumber: [13]byte{0x41, 0x42, 0x43, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
	},
}

var testCasesVehicleRegistrationIdentification = []struct {
	data     []byte
	expected VehicleRegistrationIdentification
}{
	{
		data:     vehicleRegistrationIdentificationData,
		expected: expectedVehicleRegistrationIdentification,
	},
}

func TestDecodeVehicleRegistrationIdentification(t *testing.T) {
	for _, testCase := range testCasesVehicleRegistrationIdentification {
		ii := &VehicleRegistrationIdentification{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vehicle registration identification failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// current date time

// current date time 0x5e 0x7b 0xf0 0x80 (2020-03-26T00:00:00Z)
var currentDateTimeData = []byte{0x5e, 0x7b, 0xf0, 0x80}
var expectedCurrentDateTime = CurrentDateTime{
	Timedata: [4]byte{0x5e, 0x7b, 0xf0, 0x80},
}

var testCasesCurrentDateTime = []struct {
	data     []byte
	expected CurrentDateTime
}{
	{
		data:     currentDateTimeData,
		expected: expectedCurrentDateTime,
	},
}

func TestDecodeCurrentDateTime(t *testing.T) {
	for _, testCase := range testCasesCurrentDateTime {
		ii := &CurrentDateTime{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("current date time failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// vu downloadable period

// min downloadable time 0x5a 0xc6 0x9c 0x60 (2018-04-06T00:00:00Z)
// max downloadable time 0x5e 0x7b 0xf0 0x80 (2020-03-26T00:00:00Z)

var vuDownloadablePeriodData = []byte{0x5a, 0xc6, 0x9c, 0x60, 0x5e, 0x7b, 0xf0, 0x80}
var expectedVuDownloadablePeriod = VuDownloadablePeriod{
	MinDownloadableTime: TimeReal{Timedata: [4]byte{0x5a, 0xc6, 0x9c, 0x60}},
	MaxDownloadableTime: TimeReal{Timedata: [4]byte{0x5e, 0x7b, 0xf0, 0x80}},
}

var testCasesVuDownloadablePeriod = []struct {
	data     []byte
	expected VuDownloadablePeriod
}{
	{
		data:     vuDownloadablePeriodData,
		expected: expectedVuDownloadablePeriod,
	},
}

func TestDecodeVuDownloadablePeriod(t *testing.T) {
	for _, testCase := range testCasesVuDownloadablePeriod {
		ii := &VuDownloadablePeriod{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vu downloadable period failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// card slots status

// card slots status 0x01 (driver card in driver slot)
var cardSlotsStatusData = []byte{0x01}
var expectedCardSlotsStatus = CardSlotsStatus(0x01)

var testCasesCardSlotsStatus = []struct {
	data     []byte
	expected CardSlotsStatus
}{
	{
		data:     cardSlotsStatusData,
		expected: expectedCardSlotsStatus,
	},
}

func TestDecodeCardSlotsStatus(t *testing.T) {
	for _, testCase := range testCasesCardSlotsStatus {
		c := CardSlotsStatus(0)
		ii := &c
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("card slots status failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// vu download activity data

// downloading time 0x5e 0x7b 0xf0 0x80 (2020-03-26T00:00:00Z)
// card type 1 (driver card)
// card issuing member state 0x0a
// card number  0x31 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 ("1000000000000000")
// company or workshop name 0x01 0x41 0x41 0x41 0x41 0x41 0x41 0x41 0x20 ... 0x20 (codepage 1, "AAAAAAA                            ")
var vuDownloadActivityDataFirstGenData = []byte{0x5e, 0x7b, 0xf0, 0x80, 0x01, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x01, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20}
var expectedVuDownloadActivityDataFirstGen = VuDownloadActivityDataFirstGen{
	DownloadingTime: TimeReal{Timedata: [4]byte{0x5e, 0x7b, 0xf0, 0x80}},
	FullCardNumber: FullCardNumber{
		CardType:               1,
		CardIssuingMemberState: 0x0a,
		CardNumber:             CardNumber{0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30},
	},
	CompanyOrWorkshopName: Name{
		CodePage: 1,
		Name:     [35]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
	},
}

var testCasesVuDownloadActivityDataFirstGen = []struct {
	data     []byte
	expected VuDownloadActivityDataFirstGen
}{
	{
		data:     vuDownloadActivityDataFirstGenData,
		expected: expectedVuDownloadActivityDataFirstGen,
	},
}

func TestDecodeVuDownloadActivityDataFirstGen(t *testing.T) {
	for _, testCase := range testCasesVuDownloadActivityDataFirstGen {
		ii := &VuDownloadActivityDataFirstGen{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vu download activity failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// vu company locks data

// no of locks 2
// lock in time 1 0x5e 0x77 0x8b 0x80 (2020-03-22T17:00:00Z)
// lock out time 1 0x5e 0x77 0xd0 0x2c (2020-03-22T21:53:00Z)
// company name 1 0x01 0x41 0x41 0x41 0x41 0x41 0x41 0x41 0x20 ... 0x20 (codepage 1, "AAAAAAA                            ")
// company address 1 0x01 0x42 0x42 0x42 0x42 0x42 0x20 ... 0x20 (codepage 1, "BBBBB                              ")
// company card number 1
//  card type 1
//  card issuing member state 0x0a
//  card number 0x31 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 ("1000000000000000")
// lock in time 2 0x5e 0x79 0x81 0x4c (2020-03-24T04:41:00Z)
// lock out time 2 0x5e 0x79 0xd3 0xcc (2020-03-24T10:33:00Z)
// company name 2 0x01 0x42 0x42 0x42 0x42 0x42 0x20 ... 0x20 (codepage 1, "BBBBB                              ")
// company address 2 0x01 0x41 0x41 0x41 0x41 0x41 0x41 0x41 0x20 ... 0x20 (codepage 1, "AAAAAAA                            ")
// company card number 2
//  card type 1
//  card issuing member state 0x0a
//  card number 0x31 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 0x30 ("1000000000000000")
var vuCompanyLocksDataFirstGenData = []byte{0x02, 0x5e, 0x77, 0x8b, 0x80, 0x5e, 0x77, 0xd0, 0x2c, 0x01, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x42, 0x42, 0x42, 0x42, 0x42, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5e, 0x79, 0x81, 0x4c, 0x5e, 0x79, 0xd3, 0xcc, 0x01, 0x42, 0x42, 0x42, 0x42, 0x42, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30}
var expectedVuCompanyLocksDataFirstGen = VuCompanyLocksDataFirstGen{
	NoOfLocks: 2,
	VuCompanyLocksRecords: []VuCompanyLocksRecordFirstGen{
		{
			LockInTime:  TimeReal{Timedata: [4]byte{0x5e, 0x77, 0x8b, 0x80}},
			LockOutTime: TimeReal{Timedata: [4]byte{0x5e, 0x77, 0xd0, 0x2c}},
			CompanyName: Name{
				CodePage: 1,
				Name:     [35]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
			},
			CompanyAddress: Address{
				CodePage: 1,
				Address:  [35]byte{0x42, 0x42, 0x42, 0x42, 0x42, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
			},
			CompanyCardNumber: FullCardNumber{
				CardType:               1,
				CardIssuingMemberState: 0x0a,
				CardNumber:             CardNumber{0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30},
			},
		},
		{
			LockInTime:  TimeReal{Timedata: [4]byte{0x5e, 0x79, 0x81, 0x4c}},
			LockOutTime: TimeReal{Timedata: [4]byte{0x5e, 0x79, 0xd3, 0xcc}},
			CompanyName: Name{
				CodePage: 1,
				Name:     [35]byte{0x42, 0x42, 0x42, 0x42, 0x42, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
			},
			CompanyAddress: Address{
				CodePage: 1,
				Address:  [35]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
			},
			CompanyCardNumber: FullCardNumber{
				CardType:               1,
				CardIssuingMemberState: 0x0a,
				CardNumber:             CardNumber{0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30},
			},
		},
	},
}

var testCasesVuCompanyLocksDataFirstGen = []struct {
	data     []byte
	expected VuCompanyLocksDataFirstGen
}{
	{
		data:     vuCompanyLocksDataFirstGenData,
		expected: expectedVuCompanyLocksDataFirstGen,
	},
}

func TestDecodeVuCompanyLocksDataFirstGen(t *testing.T) {
	for _, testCase := range testCasesVuCompanyLocksDataFirstGen {
		ii := &VuCompanyLocksDataFirstGen{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vu download activity failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// vu control activity data

var vuControlActivityDataFirstGenData = []byte{0x02, 0x01, 0x5e, 0x77, 0xd0, 0x2c, 0x03, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5e, 0x77, 0x8b, 0x80, 0x5e, 0x77, 0xd0, 0x2c, 0x01, 0x5e, 0x79, 0xd3, 0xcc, 0x03, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x5e, 0x79, 0x81, 0x4c, 0x5e, 0x79, 0xd3, 0xcc}
var expectedVuControlActivityDataFirstGen = VuControlActivityDataFirstGen{
	NoOfControls: 2,
	VuControlActivityRecords: []VuControlActivityRecordFirstGen{
		{
			ControlType: 1,
			ControlTime: TimeReal{Timedata: [4]byte{0x5e, 0x77, 0xd0, 0x2c}},
			ControlCardNumber: FullCardNumber{
				CardType:               3,
				CardIssuingMemberState: 0x0a,
				CardNumber:             CardNumber{0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30},
			},
			DownloadPeriodBeginTime: TimeReal{Timedata: [4]byte{0x5e, 0x77, 0x8b, 0x80}},
			DownloadPeriodEndTime:   TimeReal{Timedata: [4]byte{0x5e, 0x77, 0xd0, 0x2c}},
		},
		{
			ControlType: 1,
			ControlTime: TimeReal{Timedata: [4]byte{0x5e, 0x79, 0xd3, 0xcc}},
			ControlCardNumber: FullCardNumber{
				CardType:               3,
				CardIssuingMemberState: 0x0a,
				CardNumber:             CardNumber{0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30},
			},
			DownloadPeriodBeginTime: TimeReal{Timedata: [4]byte{0x5e, 0x79, 0x81, 0x4c}},
			DownloadPeriodEndTime:   TimeReal{Timedata: [4]byte{0x5e, 0x79, 0xd3, 0xcc}},
		},
	},
}

var testCasesVuControlActivityDataFirstGen = []struct {
	data     []byte
	expected VuControlActivityDataFirstGen
}{
	{
		data:     vuControlActivityDataFirstGenData,
		expected: expectedVuControlActivityDataFirstGen,
	},
}

func TestDecodeVuControlActivityDataFirstGen(t *testing.T) {
	for _, testCase := range testCasesVuControlActivityDataFirstGen {
		ii := &VuControlActivityDataFirstGen{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vu download activity failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// signature

var signatureFirstGenData = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f}
var expectedSignatureFirstGen = SignatureFirstGen{
	Signature: [128]byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f},
}

var testCasesSignatureFirstGen = []struct {
	data     []byte
	expected SignatureFirstGen
}{
	{
		data:     signatureFirstGenData,
		expected: expectedSignatureFirstGen,
	},
}

func TestDecodeSignatureFirstGen(t *testing.T) {
	for _, testCase := range testCasesSignatureFirstGen {
		ii := &SignatureFirstGen{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vu download activity failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// full overview structure (1st gen)

var ov1 = append(memberStateCertificateFirstGenData, vuCertificateFirstGenData...)
var ov2 = append(vehicleIdentificationNumberData, vehicleRegistrationIdentificationData...)
var ov3 = append(ov1, ov2...)
var ov4 = append(ov3, currentDateTimeData...)
var ov5 = append(ov4, vuDownloadablePeriodData...)
var ov6 = append(ov5, cardSlotsStatusData...)
var ov7 = append(ov6, vuDownloadActivityDataFirstGenData...)
var ov8 = append(ov7, vuCompanyLocksDataFirstGenData...)
var ov9 = append(ov8, vuControlActivityDataFirstGenData...)
var vuWithOverviewFirstGenData = append(append([]byte{0x76, 0x01}, ov9...), signatureFirstGenData...)
var expectedVuOverviewFirstGen = VuOverviewFirstGen{
	MemberStateCertificate:            expectedMemberStateCertificateFirstGen,
	VuCertificate:                     expectedVuCertificateFirstGen,
	VehicleIdentificationNumber:       expectedVehicleIdentificationNumber,
	VehicleRegistrationIdentification: expectedVehicleRegistrationIdentification,
	CurrentDateTime:                   expectedCurrentDateTime,
	VuDownloadablePeriod:              expectedVuDownloadablePeriod,
	CardSlotsStatus:                   expectedCardSlotsStatus,
	VuDownloadActivityData:            expectedVuDownloadActivityDataFirstGen,
	VuCompanyLocksData:                expectedVuCompanyLocksDataFirstGen,
	VuControlActivityData:             expectedVuControlActivityDataFirstGen,
	Signature:                         expectedSignatureFirstGen,
}
var expectedVu = Vu{
	VuOverviewFirstGen: expectedVuOverviewFirstGen,
}

var testCasesVuOverviewFirstGen = []struct {
	data     []byte
	expected Vu
}{
	{
		data:     vuWithOverviewFirstGenData,
		expected: expectedVu,
	},
}

func TestDecodeVuOverviewFirstGen(t *testing.T) {
	for _, testCase := range testCasesVuOverviewFirstGen {
		ii := &Vu{}
		data := testCase.data
		UnmarshalTV(data, ii)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vu overview 1st gen failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// Overview 2nd gen

// member state cert record array

var memberStateCertificateSecondGenData = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc}
var memberStateCertificateRecordArrayData = append([]byte{RecordTypeMemberStateCertificate, 0x00, byte(len(memberStateCertificateSecondGenData)), 0x00, 0x01}, memberStateCertificateSecondGenData...)
var expectedMemberStateCertificateSecondGen = MemberStateCertificateSecondGen{
	Certificate: []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc},
}
var expectedMemberStateCertificateRecordArray = MemberStateCertificateRecordArray{
	RecordType:  RecordTypeMemberStateCertificate,
	RecordSize:  uint16(len(memberStateCertificateSecondGenData)),
	NoOfRecords: 1,
	Records:     []MemberStateCertificateSecondGen{expectedMemberStateCertificateSecondGen},
}

var testCasesMemberStateCertificateRecordArray = []struct {
	data     []byte
	expected MemberStateCertificateRecordArray
}{
	{
		data:     memberStateCertificateRecordArrayData,
		expected: expectedMemberStateCertificateRecordArray,
	},
}

func TestDecodeMemberStateCertificateRecordArray(t *testing.T) {
	for _, testCase := range testCasesMemberStateCertificateRecordArray {
		ii := &MemberStateCertificateRecordArray{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("member state certificate record array failure: %v should be %v", ii, testCase.expected)
		}
	}
}

var vuCertificateSecondGenData = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc}
var vuCertificateRecordArrayData = append([]byte{RecordTypeVuCertificate, 0x00, byte(len(vuCertificateSecondGenData)), 0x00, 0x01}, vuCertificateSecondGenData...)
var expectedVuCertificateSecondGen = VuCertificateSecondGen{
	Certificate: []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc},
}
var expectedVuCertificateRecordArray = VuCertificateRecordArray{
	RecordType:  RecordTypeVuCertificate,
	RecordSize:  uint16(len(memberStateCertificateSecondGenData)),
	NoOfRecords: 1,
	Records:     []VuCertificateSecondGen{expectedVuCertificateSecondGen},
}

var testCasesVuCertificateRecordArray = []struct {
	data     []byte
	expected VuCertificateRecordArray
}{
	{
		data:     vuCertificateRecordArrayData,
		expected: expectedVuCertificateRecordArray,
	},
}

func TestDecodeVuCertificateRecordArray(t *testing.T) {
	for _, testCase := range testCasesVuCertificateRecordArray {
		ii := &VuCertificateRecordArray{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vu certificate record array failure: %v should be %v", ii, testCase.expected)
		}
	}
}

var vehicleIdentificationNumberRecordArrayData = append([]byte{RecordTypeVehicleIdentificationNumber, 0x00, byte(len(vehicleIdentificationNumberData)), 0x00, 0x01}, vehicleIdentificationNumberData...)
var expectedVehicleIdentificationNumberRecordArray = VehicleIdentificationNumberRecordArray{
	RecordType:  RecordTypeVehicleIdentificationNumber,
	RecordSize:  uint16(len(vehicleIdentificationNumberData)),
	NoOfRecords: 1,
	Records:     []VehicleIdentificationNumber{expectedVehicleIdentificationNumber},
}

var testCasesVehicleIdentificationNumberRecordArray = []struct {
	data     []byte
	expected VehicleIdentificationNumberRecordArray
}{
	{
		data:     vehicleIdentificationNumberRecordArrayData,
		expected: expectedVehicleIdentificationNumberRecordArray,
	},
}

func TestDecodeVehicleIdentificationNumberRecordArray(t *testing.T) {
	for _, testCase := range testCasesVehicleIdentificationNumberRecordArray {
		ii := &VehicleIdentificationNumberRecordArray{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vehicle identification number record array failure: %v should be %v", ii, testCase.expected)
		}
	}
}

var vehicleRegistrationNumberData = []byte{0x01, 0x41, 0x42, 0x43, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20}
var vehicleRegistrationNumberRecordArrayData = append([]byte{RecordTypeVehicleRegistrationNumber, 0x00, byte(len(vehicleRegistrationNumberData)), 0x00, 0x01}, vehicleRegistrationNumberData...)
var expectedVehicleRegistrationNumber = VehicleRegistrationNumber{
	CodePage:         1,
	VehicleRegNumber: [13]byte{0x41, 0x42, 0x43, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
}
var expectedVehicleRegistrationNumberRecordArray = VehicleRegistrationNumberRecordArray{
	RecordType:  RecordTypeVehicleRegistrationNumber,
	RecordSize:  uint16(len(vehicleRegistrationNumberData)),
	NoOfRecords: 1,
	Records:     []VehicleRegistrationNumber{expectedVehicleRegistrationNumber},
}

var testCasesVehicleRegistrationNumberRecordArray = []struct {
	data     []byte
	expected VehicleRegistrationNumberRecordArray
}{
	{
		data:     vehicleRegistrationNumberRecordArrayData,
		expected: expectedVehicleRegistrationNumberRecordArray,
	},
}

func TestDecodeVehicleRegistrationNumberRecordArray(t *testing.T) {
	for _, testCase := range testCasesVehicleRegistrationNumberRecordArray {
		ii := &VehicleRegistrationNumberRecordArray{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vehicle registration number record array failure: %v should be %v", ii, testCase.expected)
		}
	}
}

var currentDateTimeRecordArrayData = append([]byte{RecordTypeCurrentDateTime, 0x00, byte(len(currentDateTimeData)), 0x00, 0x01}, currentDateTimeData...)
var expectedCurrentDateTimeRecordArray = CurrentDateTimeRecordArray{
	RecordType:  RecordTypeCurrentDateTime,
	RecordSize:  uint16(len(currentDateTimeData)),
	NoOfRecords: 1,
	Records:     []CurrentDateTime{expectedCurrentDateTime},
}

var testCasesCurrentDateTimeRecordArray = []struct {
	data     []byte
	expected CurrentDateTimeRecordArray
}{
	{
		data:     currentDateTimeRecordArrayData,
		expected: expectedCurrentDateTimeRecordArray,
	},
}

func TestDecodeCurrentDateTimeRecordArray(t *testing.T) {
	for _, testCase := range testCasesCurrentDateTimeRecordArray {
		ii := &CurrentDateTimeRecordArray{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("current date time record array failure: %v should be %v", ii, testCase.expected)
		}
	}
}

var vuDownloadablePeriodRecordArrayData = append([]byte{RecordTypeVuDownloadablePeriod, 0x00, byte(len(vuDownloadablePeriodData)), 0x00, 0x01}, vuDownloadablePeriodData...)
var expectedVuDownloadablePeriodRecordArray = VuDownloadablePeriodRecordArray{
	RecordType:  RecordTypeVuDownloadablePeriod,
	RecordSize:  uint16(len(vuDownloadablePeriodData)),
	NoOfRecords: 1,
	Records:     []VuDownloadablePeriod{expectedVuDownloadablePeriod},
}

var testCasesVuDownloadablePeriodRecordArray = []struct {
	data     []byte
	expected VuDownloadablePeriodRecordArray
}{
	{
		data:     vuDownloadablePeriodRecordArrayData,
		expected: expectedVuDownloadablePeriodRecordArray,
	},
}

func TestDecodeVuDownloadablePeriodRecordArray(t *testing.T) {
	for _, testCase := range testCasesVuDownloadablePeriodRecordArray {
		ii := &VuDownloadablePeriodRecordArray{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("downloadable period record array failure: %v should be %v", ii, testCase.expected)
		}
	}
}

var cardSlotsStatusRecordArrayData = append([]byte{RecordTypeCardSlotsStatus, 0x00, byte(len(cardSlotsStatusData)), 0x00, 0x01}, cardSlotsStatusData...)
var expectedCardSlotsStatusRecordArray = CardSlotsStatusRecordArray{
	RecordType:  RecordTypeCardSlotsStatus,
	RecordSize:  uint16(len(cardSlotsStatusData)),
	NoOfRecords: 1,
	Records:     []CardSlotsStatus{expectedCardSlotsStatus},
}

var testCasesCardSlotsStatusRecordArray = []struct {
	data     []byte
	expected CardSlotsStatusRecordArray
}{
	{
		data:     cardSlotsStatusRecordArrayData,
		expected: expectedCardSlotsStatusRecordArray,
	},
}

func TestDecodeCardSlotsStatusRecordArray(t *testing.T) {
	for _, testCase := range testCasesCardSlotsStatusRecordArray {
		ii := &CardSlotsStatusRecordArray{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("downloadable period record array failure: %v should be %v", ii, testCase.expected)
		}
	}
}

var vuDownloadActivityDataSecondGenData = []byte{0x5e, 0x7b, 0xf0, 0x80, 0x01, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x02, 0x01, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20}
var expectedVuDownloadActivityDataSecondGen = VuDownloadActivityDataSecondGen{
	DownloadingTime: TimeReal{Timedata: [4]byte{0x5e, 0x7b, 0xf0, 0x80}},
	FullCardNumberAndGeneration: FullCardNumberAndGeneration{
		FullCardNumber: FullCardNumber{
			CardType:               1,
			CardIssuingMemberState: 0x0a,
			CardNumber:             CardNumber{0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30},
		},
		Generation: Generation(2),
	},
	CompanyOrWorkshopName: Name{
		CodePage: 1,
		Name:     [35]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
	},
}
var vuDownloadActivityDataRecordArrayData = append([]byte{RecordTypeVuDownloadActivityData, 0x00, byte(len(vuDownloadActivityDataSecondGenData)), 0x00, 0x01}, vuDownloadActivityDataSecondGenData...)
var expectedVuDownloadActivityDataRecordArray = VuDownloadActivityDataRecordArray{
	RecordType:  RecordTypeVuDownloadActivityData,
	RecordSize:  uint16(len(vuDownloadActivityDataSecondGenData)),
	NoOfRecords: 1,
	Records:     []VuDownloadActivityDataSecondGen{expectedVuDownloadActivityDataSecondGen},
}

var testCasesVuDownloadActivityDataRecordArray = []struct {
	data     []byte
	expected VuDownloadActivityDataRecordArray
}{
	{
		data:     vuDownloadActivityDataRecordArrayData,
		expected: expectedVuDownloadActivityDataRecordArray,
	},
}

func TestDecodeVuDownloadActivityDataRecordArray(t *testing.T) {
	for _, testCase := range testCasesVuDownloadActivityDataRecordArray {
		ii := &VuDownloadActivityDataRecordArray{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("download activity record array failure: %v should be %v", ii, testCase.expected)
		}
	}
}

var vuCompanyLocksDataSecondGenData = []byte{0x5e, 0x77, 0x8b, 0x80, 0x5e, 0x77, 0xd0, 0x2c, 0x01, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x42, 0x42, 0x42, 0x42, 0x42, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x02}
var expectedVuCompanyLocksDataSecondGen = VuCompanyLocksRecordSecondGen{
	LockInTime:  TimeReal{Timedata: [4]byte{0x5e, 0x77, 0x8b, 0x80}},
	LockOutTime: TimeReal{Timedata: [4]byte{0x5e, 0x77, 0xd0, 0x2c}},
	CompanyName: Name{
		CodePage: 1,
		Name:     [35]byte{0x41, 0x41, 0x41, 0x41, 0x41, 0x41, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
	},
	CompanyAddress: Address{
		CodePage: 1,
		Address:  [35]byte{0x42, 0x42, 0x42, 0x42, 0x42, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20},
	},
	CompanyCardNumberAndGeneration: FullCardNumberAndGeneration{
		FullCardNumber: FullCardNumber{
			CardType:               1,
			CardIssuingMemberState: 0x0a,
			CardNumber:             CardNumber{0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30},
		},
		Generation: 2,
	},
}
var vuCompanyLocksDataRecordArrayData = append([]byte{RecordTypeVuCompanyLocksRecord, 0x00, byte(len(vuCompanyLocksDataSecondGenData)), 0x00, 0x01}, vuCompanyLocksDataSecondGenData...)
var expectedVuCompanyLocksRecordArray = VuCompanyLocksRecordArray{
	RecordType:  RecordTypeVuCompanyLocksRecord,
	RecordSize:  uint16(len(vuCompanyLocksDataSecondGenData)),
	NoOfRecords: 1,
	Records:     []VuCompanyLocksRecordSecondGen{expectedVuCompanyLocksDataSecondGen},
}

var testCasesVuCompanyLocksRecordArray = []struct {
	data     []byte
	expected VuCompanyLocksRecordArray
}{
	{
		data:     vuCompanyLocksDataRecordArrayData,
		expected: expectedVuCompanyLocksRecordArray,
	},
}

func TestDecodeVuCompanyLocksRecordArray(t *testing.T) {
	for _, testCase := range testCasesVuCompanyLocksRecordArray {
		ii := &VuCompanyLocksRecordArray{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("company locks record array failure: %v should be %v", ii, testCase.expected)
		}
	}
}

var vuControlActivityDataSecondGenData1 = []byte{0x01, 0x5e, 0x77, 0xd0, 0x2c, 0x03, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x02, 0x5e, 0x77, 0x8b, 0x80, 0x5e, 0x77, 0xd0, 0x2c}
var expectedVuControlActivityRecordSecondGen1 = VuControlActivityRecordSecondGen{
	ControlType: 1,
	ControlTime: TimeReal{Timedata: [4]byte{0x5e, 0x77, 0xd0, 0x2c}},
	ControlCardNumberAndGeneration: FullCardNumberAndGeneration{
		FullCardNumber: FullCardNumber{
			CardType:               3,
			CardIssuingMemberState: 0x0a,
			CardNumber:             CardNumber{0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30},
		},
		Generation: 2,
	},
	DownloadPeriodBeginTime: TimeReal{Timedata: [4]byte{0x5e, 0x77, 0x8b, 0x80}},
	DownloadPeriodEndTime:   TimeReal{Timedata: [4]byte{0x5e, 0x77, 0xd0, 0x2c}},
}
var vuControlActivityDataSecondGenData2 = []byte{0x01, 0x5e, 0x79, 0xd3, 0xcc, 0x03, 0x0a, 0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x02, 0x5e, 0x79, 0x81, 0x4c, 0x5e, 0x79, 0xd3, 0xcc}
var expectedVuControlActivityRecordSecondGen2 = VuControlActivityRecordSecondGen{
	ControlType: 1,
	ControlTime: TimeReal{Timedata: [4]byte{0x5e, 0x79, 0xd3, 0xcc}},
	ControlCardNumberAndGeneration: FullCardNumberAndGeneration{
		FullCardNumber: FullCardNumber{
			CardType:               3,
			CardIssuingMemberState: 0x0a,
			CardNumber:             CardNumber{0x31, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30},
		},
		Generation: 2,
	},
	DownloadPeriodBeginTime: TimeReal{Timedata: [4]byte{0x5e, 0x79, 0x81, 0x4c}},
	DownloadPeriodEndTime:   TimeReal{Timedata: [4]byte{0x5e, 0x79, 0xd3, 0xcc}},
}
var vuControlActivityRecordArrayData = append([]byte{RecordTypeVuControlActivityRecord, 0x00, byte(len(vuControlActivityDataSecondGenData1)), 0x00, 0x02}, append(vuControlActivityDataSecondGenData1, vuControlActivityDataSecondGenData2...)...)
var expectedVuControlActivityRecordArray = VuControlActivityRecordArray{
	RecordType:  RecordTypeVuControlActivityRecord,
	RecordSize:  uint16(len(vuControlActivityDataSecondGenData1)),
	NoOfRecords: 2,
	Records:     []VuControlActivityRecordSecondGen{expectedVuControlActivityRecordSecondGen1, expectedVuControlActivityRecordSecondGen2},
}

var testCasesVuControlActivityRecordArray = []struct {
	data     []byte
	expected VuControlActivityRecordArray
}{
	{
		data:     vuControlActivityRecordArrayData,
		expected: expectedVuControlActivityRecordArray,
	},
}

func TestDecodeVuControlActivityRecordArray(t *testing.T) {
	for _, testCase := range testCasesVuControlActivityRecordArray {
		ii := &VuControlActivityRecordArray{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("download control activity record array failure: %v should be %v", ii, testCase.expected)
		}
	}
}

var signatureSecondGenData = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f}
var expectedSignatureSecondGen = SignatureSecondGen{
	Signature: []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f},
}
var signatureRecordArrayData = append([]byte{RecordTypeSignature, 0x00, byte(len(signatureSecondGenData)), 0x00, 0x01}, signatureSecondGenData...)
var expectedSignatureRecordArray = SignatureRecordArray{
	RecordType:  RecordTypeSignature,
	RecordSize:  uint16(len(signatureSecondGenData)),
	NoOfRecords: 1,
	Records:     []SignatureSecondGen{expectedSignatureSecondGen},
}

var testCasesSignatureRecordArray = []struct {
	data     []byte
	expected SignatureRecordArray
}{
	{
		data:     signatureRecordArrayData,
		expected: expectedSignatureRecordArray,
	},
}

func TestDecodeSignatureRecordArray(t *testing.T) {
	for _, testCase := range testCasesSignatureRecordArray {
		ii := &SignatureRecordArray{}
		data := testCase.data
		globalSizes := make(map[string]int)
		parseASN1Field(reflect.ValueOf(ii), reflect.TypeOf(ii), -1, 0, 0, len(data), 0, data, nil, globalSizes)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vu download activity failure: %v should be %v", ii, testCase.expected)
		}
	}
}

// full overview structure (2nd gen)

var ovSecondGen1 = append(memberStateCertificateRecordArrayData, vuCertificateRecordArrayData...)
var ovSecondGen2 = append(vehicleIdentificationNumberRecordArrayData, vehicleRegistrationNumberRecordArrayData...)
var ovSecondGen3 = append(ovSecondGen1, ovSecondGen2...)
var ovSecondGen4 = append(ovSecondGen3, currentDateTimeRecordArrayData...)
var ovSecondGen5 = append(ovSecondGen4, vuDownloadablePeriodRecordArrayData...)
var ovSecondGen6 = append(ovSecondGen5, cardSlotsStatusRecordArrayData...)
var ovSecondGen7 = append(ovSecondGen6, vuDownloadActivityDataRecordArrayData...)
var ovSecondGen8 = append(ovSecondGen7, vuCompanyLocksDataRecordArrayData...)
var ovSecondGen9 = append(ovSecondGen8, vuControlActivityRecordArrayData...)
var vuWithOverviewSecondGenData = append(append([]byte{0x76, 0x21}, ovSecondGen9...), signatureRecordArrayData...)
var expectedVuOverviewSecondGen = VuOverviewSecondGen{
	MemberStateCertificateRecordArray:      expectedMemberStateCertificateRecordArray,
	VuCertificateRecordArray:               expectedVuCertificateRecordArray,
	VehicleIdentificationNumberRecordArray: expectedVehicleIdentificationNumberRecordArray,
	VehicleRegistrationNumberRecordArray:   expectedVehicleRegistrationNumberRecordArray,
	CurrentDateTimeRecordArray:             expectedCurrentDateTimeRecordArray,
	VuDownloadablePeriodRecordArray:        expectedVuDownloadablePeriodRecordArray,
	CardSlotsStatusRecordArray:             expectedCardSlotsStatusRecordArray,
	VuDownloadActivityDataRecordArray:      expectedVuDownloadActivityDataRecordArray,
	VuCompanyLocksRecordArray:              expectedVuCompanyLocksRecordArray,
	VuControlActivityRecordArray:           expectedVuControlActivityRecordArray,
	SignatureRecordArray:                   expectedSignatureRecordArray,
}
var expectedVuSecondGen = Vu{
	VuOverviewSecondGen: expectedVuOverviewSecondGen,
}

var testCasesVuOverviewSecondGen = []struct {
	data     []byte
	expected Vu
}{
	{
		data:     vuWithOverviewSecondGenData,
		expected: expectedVuSecondGen,
	},
}

func TestDecodeVuOverviewSecondGen(t *testing.T) {
	for _, testCase := range testCasesVuOverviewSecondGen {
		ii := &Vu{}
		data := testCase.data
		UnmarshalTV(data, ii)
		if !reflect.DeepEqual(testCase.expected, *ii) {
			t.Fatalf("vu overview 2nd gen failure: %v should be %v", ii, testCase.expected)
		}
	}
}
